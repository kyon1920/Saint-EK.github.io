<!DOCTYPE html>
<html lang="zh-cn" >
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  
  <meta name="author"
        content="Bruce Cheung"/>

  
  <meta name="description" content=""/>
  

  
  
  <meta name="keywords" content="blog, simple, dream"/>
  

  
  <link rel="canonical" href="https://oubc.github.io/post/l21_oscode6/"/>

  

  <title>Linux系统编程 (线&amp;进程同步 锁) &middot; Love, or death</title>

  <link rel="shortcut icon" href="https://oubc.github.io/images/favicon.ico"/>
  <link rel="stylesheet" href="https://oubc.github.io/css/animate.min.css"/>
  <link rel="stylesheet" href="https://oubc.github.io/css/remixicon.css"/>
  <link rel="stylesheet" href="https://oubc.github.io/css/zozo.css"/>
  <link rel="stylesheet" href="https://oubc.github.io/css/highlight.css"/>

  
  
</head>

<body>
<div class="main animated">
  <div class="nav_container animated fadeInDown">
  <div class="site_nav" id="site_nav">
    <ul>
      
      <li>
        <a href="/">首页</a>
      </li>
      
      <li>
        <a href="/post/">归档</a>
      </li>
      
      <li>
        <a href="/tags/">标签</a>
      </li>
      
      <li>
        <a href="/about/">关于</a>
      </li>
      
    </ul>
  </div>
  <div class="menu_icon">
    <a id="menu_icon"><i class="remixicon-links-line"></i></a>
  </div>
</div>

  <div class="header animated fadeInDown">
  <div class="site_title_container">
    <div class="site_title">
      <h1>
        <a href="https://oubc.github.io/">
          <span>Love, or death</span>
          <img src="https://oubc.github.io/images/logo.svg"/>
        </a>
      </h1>
    </div>
    <div class="description">
      <p class="sub_title">For you, a thousand times over.</p>
      <div class="my_socials">
        
        
        <a href="https://github.com/oubc" title="github" target="_blank"><i class="remixicon-github-fill"></i></a>
        
        
        
        <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=uYGOjo6OiIuLivnIyJfa1tQ" title="mail" target="_blank"><i class="remixicon-mail-fill"></i></a>
        
        
        
        <a href="http://sighttp.qq.com/msgrd?v=1&amp;uin=877771223" title="qq" target="_blank"><i class="remixicon-qq-fill"></i></a>
        
        
        
        <a href="https://github.com/oubc/oubc.github.io/blob/master/images/wx.jpg?raw=true" title="wechat" target="_blank"><i class="remixicon-wechat-fill"></i></a>
        
        
        
        <a href="https://weibo.com/u/6993631995?topnav=1&amp;wvr=6&amp;topsug=1" title="weibo" target="_blank"><i class="remixicon-weibo-fill"></i></a>
        
        
        <a href="https://oubc.github.io/index.xml" type="application/rss+xml" title="rss" target="_blank"><i class="remixicon-rss-fill"></i></a>
      </div>
    </div>
  </div>
</div>

  <div class="content">
    <div class="post_page">
      <div class="post animated fadeInDown">
        <div class="post_title post_detail_title">
          <h2><a href='/post/l21_oscode6/'>Linux系统编程 (线&amp;进程同步 锁)</a></h2>
          <span class="date">2019.10.06</span>
        </div>
        <div class="post_content markdown"><p><br>
<br>
<font color = gray size = 2>列表，展开点击跳转</font>
<br>
<details class="menu" close>
      <summary><font color=blue size = 4>线程同步</font></summary>
      <ul>
          <li><a href="#bc0">同步概念</a></li>
          <li><a href="#bc1">线程同步</a></li>
          <li><a href="#bc2">数据混乱原因</a></li>
          <li><a href="#bc3">互斥量 mutex</a></li>
          <li><a href="#bc4">主要函数及应用</a></li>
      </ul>
</details>
<details class="menu" close>
      <summary><font color=blue size = 4>死锁</font></summary>
      <ul>
          <li><a href="#bc5">死锁描述及实现</a></li>
      </ul>
</details>
<details class="menu" close>
      <summary><font color=blue size = 4>读写锁</font></summary>
      <ul>
          <li><a href="#bc6">读写锁概述</a></li>
          <li><a href="#bc7">读写锁状态</a></li>
          <li><a href="#bc8">主要函数及应用</a></li>
      </ul>
</details>
<details class="menu" close>
      <summary><font color=blue size = 4>条件变量</font></summary>
      <ul>
          <li><a href="#bc9">条件变量概述</a></li>
          <li><a href="#bc10">主要函数及应用</a></li>
          <li><a href="#bc11">条件变量的优点</a></li>
      </ul>
</details>
<details class="menu" close>
      <summary><font color=blue size = 4>信号量</font></summary>
      <ul>
          <li><a href="#bc12">信号量概述</a></li>
          <li><a href="#bc13">信号量基本操作、主要函数及应用</a></li>
      </ul>
</details>
<details class="menu" close>
      <summary><font color=blue size = 4>进程同步</font></summary>
      <ul>
          <li><a href="#bc14">互斥量 mutex</a></li>
          <li><a href="#bc15">主要函数及应用</a></li>
      </ul>
</details>
<details class="menu" close>
      <summary><font color=blue size = 4>文件锁</font></summary>
      <ul>
          <li><a href="#bc16">文件锁概述</a></li>
          <li><a href="#bc17">主要函数及应用</a></li>
      </ul>
</details>
<br>
<br>
<br>
<br>
<br><font color=black size = 5><a name="bc0">同步概念</a></font>
<br> ✦ 所谓同步，即同时起步，协调一致。不同的对象，对“同步”的理解方式略有不同，如：
<br>&nbsp;&nbsp;&nbsp;&nbsp; 设备同步是指在两个设备之间规定一个共同的时间参考；
<br>&nbsp;&nbsp;&nbsp;&nbsp; 数据库同步是指让两个或多个数据库内容保持一致，或者按需要部分保持一致；
<br>&nbsp;&nbsp;&nbsp;&nbsp; 文件同步是指让两个或多个文件夹里的文件保持一致
<br>&nbsp;&nbsp;&nbsp;&nbsp; 而在编程、通信中的同步中的“同”字应是指协同、协助、互相配合，主旨在协同步调，按预定的先后次序运行。
<br>
<br><font color=black size = 5><a name="bc1">线程同步</a></font>
<br>&nbsp;&nbsp;&nbsp;&nbsp; 同步即协同步调，按预定的先后次序运行。
<br> ✦ 线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回，同时其它线程为保证数据一致性，不能调用该功能。
<br> ✦ 举例1：银行存款 5000。柜台，折：取3000；提款机，卡：取 3000。剩余：2000
<br> ✦ 举例2：内存中100字节，线程T1欲填入全1，线程T2欲填入全0。但如果T1执行了50个字节失去cpu，T2执行，会将T1写过的内容覆盖。当T1再次获得cpu继续，从失去cpu的位置向后写入1，当执行结束，内存中的100字节，既不是全1，也不是全0。
<br> ✦ 产生的现象叫做“与时间有关的错误”(time related)，为了避免这种数据混乱，线程需要同步。
<br> ✦ “同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。
<br> ✦ 因此，所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。
<br>
<br><font color=black size = 5><a name="bc2">数据混乱原因</a></font>
<br> 0、资源共享（独享资源则不会）
<br> 1、调度随机（意味着数据访问会出现竞争）
<br> 2、线程间缺乏必要的同步机制。
<br> ✦ 以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享，只要共享资源，就一定会出现竞争，只要存在竞争关系，数据就很容易出现混乱。
<br> ✦ 所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。
<br>
<br><font color=black size = 5><a name="bc3">互斥量 mutex </a></font>
<br> ✦ Linux中提供一把互斥锁mutex（也称之为互斥量）。
<br> ✦ 每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。
<br> ✦ 资源还是共享的，线程间也还是竞争的
<br> ✦ 但是通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。
<br><img src="https://github.com/oubc/oubc.github.io/blob/master/images/L21_OScode.png?raw=true" width="800" height="600" />
<br> 🎈 注意：同一时刻，只能有一个线程持有该锁。
<br> ✦ 当A线程对某个全局变量加锁访问，B线程在访问前尝试加锁，拿不到锁，B线程阻塞，C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。
<br> ✦ 所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制，但是没有强制限定。
<br> ✦ 因此，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。
<br>
<br><font color=black size = 5><a name="bc3">主要函数及应用</a></font>
<br> ✦ pthread_mutex_init() 函数
<br> ✦ pthread_mutex_destroy() 函数
<br> ✦ pthread_mutex_lock() 函数
<br> ✦ pthread_mutex_trylock() 函数
<br> ✦ pthread_mutex_unlock() 函数
<br>  以上5个函数的返回值都是：成功返回0， 失败返回错误号。
<br> ✦ pthread_mutex_t 类型，其本质是一个结构体，为简化理解，应用时可忽略其实现细节，简单当成整数看待。
<br> ✦ pthread_mutex_t mutex; 变量mutex只有两种取值1、0。
<br> ✧ pthread_mutex_init() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 初始化一个互斥锁(互斥量) → 初值可看作1
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
<br>&nbsp;&nbsp;&nbsp;&nbsp; 参数1：传出参数，调用时应传 &amp;mutex
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  注意：restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成，不能通过除本指针以外的其他变量或指针修改
<br>&nbsp;&nbsp;&nbsp;&nbsp; 参数2：互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。 参照APUE.12.4同步属性
<br>&nbsp;&nbsp;&nbsp;&nbsp; 0、静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。e.g.  pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;
<br>&nbsp;&nbsp;&nbsp;&nbsp; 1、动态初始化：局部变量应采用动态初始化。e.g.  pthread_mutex_init(&amp;mutex, NULL)
<br> ✧ pthread_mutex_destroy() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 销毁一个互斥锁
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_mutex_destroy(pthread_mutex_t *mutex);
<br> ✧ pthread_mutex_lock() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 加锁，可理解为将mutex--（或-1）
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_mutex_lock(pthread_mutex_t *mutex);
<br> ✧ pthread_mutex_unlock函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 解锁，可理解为将mutex ++（或+1）
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_mutex_unlock(pthread_mutex_t *mutex);
<br> ✧ pthread_mutex_trylock函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 尝试加锁
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_mutex_trylock(pthread_mutex_t *mutex);
<br>  加锁与解锁
<br> ✧ lock与unlock：
<br>&nbsp;&nbsp;&nbsp;&nbsp; lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。
<br>&nbsp;&nbsp;&nbsp;&nbsp; unlock主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。
<br>&nbsp;&nbsp;&nbsp;&nbsp; 例如：T1 T2 T3 T4 使用一把mutex锁。T1加锁成功，其他线程均阻塞，直至T1解锁。T1解锁后，T2 T3 T4均被唤醒，并自动再次尝试加锁。
<br>&nbsp;&nbsp;&nbsp;&nbsp; 可假想mutex锁 init成功初值为1、lock 功能是将mutex--、unlock将mutex++
<br> ✧ lock与trylock：
<br>&nbsp;&nbsp;&nbsp;&nbsp;lock加锁失败会阻塞，等待锁释放。
<br>&nbsp;&nbsp;&nbsp;&nbsp;trylock加锁失败直接返回错误号(如：EBUSY)，不阻塞。
<br>  加锁步骤测试：
<br>&nbsp;&nbsp;&nbsp;&nbsp; 程序：该程序是非常典型的，由于共享、竞争而没有加任何同步机制，导致产生于时间有关的错误，造成数据混乱。
<br> 👦 编程实战：加锁前造成的数据混乱
<br><div style="width:100%;border:1px #e3e3e3 solid;"><div style="width:100%;font-family:'Consolas', 'Courier New';font-size:12px;border-bottom:1px solid #e3e3e3;margin-top:5px;color:#000000;">&nbsp;C++ Code&nbsp;</div><table style="width:100%;font-family:'Consolas', 'Courier New';font-size:12px;vertical-align:text-top;line-height:15px;" border="0" cellspacing="0" cellpadding="0"><tr><td style="color:#008284;background-color:#e3e3e3;vertical-align:text-top;"><div style="margin:7px;text-align:right;white-space:nowrap;"><nobr>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br></nobr></div></td><td style="background-color:#008284;padding:1px;"><div style="border:1px #008284 solid;"></div></td><td style="background-color:#efefef;width:100%;vertical-align:text-top;color:#000000;"><div style="margin:7px;"><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;stdio.h&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;pthread.h&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;unistd.h&gt;<BR>
<BR>
</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*tfn(</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*arg)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;srand(time(</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">while</span><span style="color:#000000;">&nbsp;(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">)&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span style="color:#800000;">&quot;hello&nbsp;&quot;</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误<BR>
</span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(rand()&nbsp;%&nbsp;</span><span style="color:#ff0000;">3</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span style="color:#800000;">&quot;world\n&quot;</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(rand()&nbsp;%&nbsp;</span><span style="color:#ff0000;">3</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">return</span><span style="color:#000000;">&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">;<BR>
}<BR>
</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;main(</span><span style="color:#8000ff;">void</span><span style="color:#000000;">)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;tid;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;srand(time(</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">,&nbsp;tfn,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">while</span><span style="color:#000000;">&nbsp;(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span style="color:#800000;">&quot;HELLO&nbsp;&quot;</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(rand()&nbsp;%&nbsp;</span><span style="color:#ff0000;">3</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span style="color:#800000;">&quot;WORLD\n&quot;</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(rand()&nbsp;%&nbsp;</span><span style="color:#ff0000;">3</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(tid,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">return</span><span style="color:#000000;">&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">;<BR>
}</span></div></td></tr></table></div>
<br> 👦 编程实战：加锁后不会造成数据混乱
<br><div style="width:100%;border:1px #e3e3e3 solid;"><div style="width:100%;font-family:'Consolas', 'Courier New';font-size:12px;border-bottom:1px solid #e3e3e3;margin-top:5px;color:#000000;">&nbsp;C++ Code&nbsp;</div><table style="width:100%;font-family:'Consolas', 'Courier New';font-size:12px;vertical-align:text-top;line-height:15px;" border="0" cellspacing="0" cellpadding="0"><tr><td style="color:#008284;background-color:#e3e3e3;vertical-align:text-top;"><div style="margin:7px;text-align:right;white-space:nowrap;"><nobr>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br></nobr></div></td><td style="background-color:#008284;padding:1px;"><div style="border:1px #008284 solid;"></div></td><td style="background-color:#efefef;width:100%;vertical-align:text-top;color:#000000;"><div style="margin:7px;"><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;stdio.h&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;pthread.h&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;unistd.h&gt;<BR>
<BR>
pthread_mutex_t&nbsp;mutex;<BR>
<BR>
</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*tfn(</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*arg)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;srand(time(</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">while</span><span style="color:#000000;">&nbsp;(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">)&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_lock(&amp;mutex);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span style="color:#800000;">&quot;hello&nbsp;&quot;</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">/*模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误*/</span><span style="color:#000000;"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(rand()&nbsp;%&nbsp;</span><span style="color:#ff0000;">3</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span style="color:#800000;">&quot;world\n&quot;</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_unlock(&amp;mutex);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(rand()&nbsp;%&nbsp;</span><span style="color:#ff0000;">3</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">return</span><span style="color:#000000;">&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">;<BR>
}<BR>
</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;main(</span><span style="color:#8000ff;">void</span><span style="color:#000000;">)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;tid;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_init(&amp;mutex,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;srand(time(</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">,&nbsp;tfn,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">while</span><span style="color:#000000;">&nbsp;(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">)&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_lock(&amp;mutex);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span style="color:#800000;">&quot;HELLO&nbsp;&quot;</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(rand()&nbsp;%&nbsp;</span><span style="color:#ff0000;">3</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span style="color:#800000;">&quot;WORLD\n&quot;</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_unlock(&amp;mutex);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(rand()&nbsp;%&nbsp;</span><span style="color:#ff0000;">3</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_cancel(tid);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(tid,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_destroy(&amp;mutex);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">return</span><span style="color:#000000;">&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">;<BR>
}</span></div></td></tr></table></div>
<br> 👦 在访问共享资源前加锁，访问结束后立即解锁、锁的“粒度”应越小越好。
<br>
<br><font color=black size = 5><a name="bc5">死锁实现</a></font>
<br> ✦ 0、线程试图对同一个互斥量A加锁两次。
<br> ✦ 1、线程1拥有A锁，请求获得B锁；线程2拥有B锁，请求获得A锁
<br> 👦 编程实战0：实现上述第一种情况
<br><div style="width:100%;border:1px #e3e3e3 solid;"><div style="width:100%;font-family:'Consolas', 'Courier New';font-size:12px;border-bottom:1px solid #e3e3e3;margin-top:5px;color:#000000;">&nbsp;C++ Code&nbsp;</div><table style="width:100%;font-family:'Consolas', 'Courier New';font-size:12px;vertical-align:text-top;line-height:15px;" border="0" cellspacing="0" cellpadding="0"><tr><td style="color:#008284;background-color:#e3e3e3;vertical-align:text-top;"><div style="margin:7px;text-align:right;white-space:nowrap;"><nobr>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br></nobr></div></td><td style="background-color:#008284;padding:1px;"><div style="border:1px #008284 solid;"></div></td><td style="background-color:#efefef;width:100%;vertical-align:text-top;color:#000000;"><div style="margin:7px;"><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;iostream&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;stdlib.h&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;pthread.h&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;unistd.h&gt;<BR>
</span><span style="color:#0000ff;">using</span><span style="color:#000000;">&nbsp;</span><span style="color:#0000ff;">namespace</span><span style="color:#000000;">&nbsp;std;<BR>
<BR>
pthread_mutex_t&nbsp;mutex;<BR>
<BR>
</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*deadLockfun(</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*arg)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;ret;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;srand(time(</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;This&nbsp;is&nbsp;first&nbsp;lock...&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;pthread_mutex_lock(&amp;mutex);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//&nbsp;第一次加锁<BR>
</span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">if</span><span style="color:#000000;">&nbsp;(ret&nbsp;==&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;The&nbsp;first&nbsp;lock&nbsp;success!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">else</span><span style="color:#000000;"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;The&nbsp;first&nbsp;lock&nbsp;failed!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;Now,&nbsp;I&nbsp;try&nbsp;second&nbsp;lock&nbsp;this&nbsp;program...&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;pthread_mutex_lock(&amp;mutex);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">if</span><span style="color:#000000;">&nbsp;(ret&nbsp;==&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;The&nbsp;second&nbsp;lock&nbsp;success!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">else</span><span style="color:#000000;"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;The&nbsp;second&nbsp;lock&nbsp;failed!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;hello&nbsp;&quot;</span><span style="color:#000000;">;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(rand()%</span><span style="color:#ff0000;">2</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;world!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;pthread_mutex_unlock(&amp;mutex);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">if</span><span style="color:#000000;">&nbsp;(ret&nbsp;==&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;Unlock&nbsp;success!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">else</span><span style="color:#000000;"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;Unlock&nbsp;failed!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;main()<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;ret;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;tid;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;pthread_mutex_init(&amp;mutex,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">if</span><span style="color:#000000;">&nbsp;(</span><span style="color:#ff0000;">0</span><span style="color:#000000;">&nbsp;==&nbsp;ret)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;Lock&nbsp;init&nbsp;success!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">else</span><span style="color:#000000;"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;Lock&nbsp;init&nbsp;failed!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">,&nbsp;deadLockfun,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(</span><span style="color:#ff0000;">2</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">/*ret&nbsp;=&nbsp;pthread_mutex_destroy(&amp;mutex);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(0&nbsp;==&nbsp;ret)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;&quot;Lock&nbsp;destroy&nbsp;success!&quot;&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;&quot;Lock&nbsp;destroy&nbsp;failed!&quot;&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}*/</span><span style="color:#000000;"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">while</span><span style="color:#000000;">(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">return</span><span style="color:#000000;">&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">;<BR>
}</span></div></td></tr></table></div>
<br> 👦 编程实战1：实现上述第二种情况
<br><div style="width:100%;border:1px #e3e3e3 solid;"><div style="width:100%;font-family:'Consolas', 'Courier New';font-size:12px;border-bottom:1px solid #e3e3e3;margin-top:5px;color:#000000;">&nbsp;C++ Code&nbsp;</div><table style="width:100%;font-family:'Consolas', 'Courier New';font-size:12px;vertical-align:text-top;line-height:15px;" border="0" cellspacing="0" cellpadding="0"><tr><td style="color:#008284;background-color:#e3e3e3;vertical-align:text-top;"><div style="margin:7px;text-align:right;white-space:nowrap;"><nobr>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br></nobr></div></td><td style="background-color:#008284;padding:1px;"><div style="border:1px #008284 solid;"></div></td><td style="background-color:#efefef;width:100%;vertical-align:text-top;color:#000000;"><div style="margin:7px;"><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;iostream&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;stdlib.h&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;pthread.h&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;unistd.h&gt;<BR>
</span><span style="color:#0000ff;">using</span><span style="color:#000000;">&nbsp;</span><span style="color:#0000ff;">namespace</span><span style="color:#000000;">&nbsp;std;<BR>
<BR>
pthread_mutex_t&nbsp;mutex0;<BR>
pthread_mutex_t&nbsp;mutex1;<BR>
<BR>
</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*deadLockfun0(</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*arg)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;ret;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;srand(time(</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;I'm&nbsp;child&nbsp;pthread0...&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;pthread_mutex_lock(&amp;mutex0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">if</span><span style="color:#000000;">&nbsp;(ret&nbsp;==&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;The&nbsp;lock0&nbsp;success!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">else</span><span style="color:#000000;"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;The&nbsp;lock0&nbsp;failed!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;Now,&nbsp;I&nbsp;try&nbsp;request&nbsp;lock1&nbsp;this&nbsp;program...&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(</span><span style="color:#ff0000;">2</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;pthread_mutex_lock(&amp;mutex1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">if</span><span style="color:#000000;">&nbsp;(ret&nbsp;==&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;The&nbsp;lock1&nbsp;success!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">else</span><span style="color:#000000;"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;The&nbsp;lock1&nbsp;failed!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*deadLockfun1(</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*arg)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;ret;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;srand(time(</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;I'm&nbsp;child&nbsp;pthread1...&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;pthread_mutex_lock(&amp;mutex1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">if</span><span style="color:#000000;">&nbsp;(ret&nbsp;==&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;The&nbsp;lock1&nbsp;success!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">else</span><span style="color:#000000;"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;The&nbsp;lock1&nbsp;failed!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;Now,&nbsp;I&nbsp;try&nbsp;request&nbsp;lock0&nbsp;this&nbsp;program...&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(</span><span style="color:#ff0000;">2</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;pthread_mutex_lock(&amp;mutex0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">if</span><span style="color:#000000;">&nbsp;(ret&nbsp;==&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;The&nbsp;lock0&nbsp;success!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">else</span><span style="color:#000000;"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;The&nbsp;lock0&nbsp;failed!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;main()<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;ret;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;tid;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;pthread_mutex_init(&amp;mutex0,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">if</span><span style="color:#000000;">&nbsp;(</span><span style="color:#ff0000;">0</span><span style="color:#000000;">&nbsp;==&nbsp;ret)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;Lock0&nbsp;init&nbsp;success!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">else</span><span style="color:#000000;"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;Lock0&nbsp;init&nbsp;failed!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;pthread_mutex_init(&amp;mutex1,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">if</span><span style="color:#000000;">&nbsp;(</span><span style="color:#ff0000;">0</span><span style="color:#000000;">&nbsp;==&nbsp;ret)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;Lock1&nbsp;init&nbsp;success!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">else</span><span style="color:#000000;"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;</span><span style="color:#800000;">&quot;Lock1&nbsp;init&nbsp;failed!&quot;</span><span style="color:#000000;">&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">,&nbsp;deadLockfun0,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">,&nbsp;deadLockfun1,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(</span><span style="color:#ff0000;">2</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">/*ret&nbsp;=&nbsp;pthread_mutex_destroy(&amp;mutex0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(0&nbsp;==&nbsp;ret)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;&quot;Lock&nbsp;destroy&nbsp;success!&quot;&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;&quot;Lock&nbsp;destroy&nbsp;failed!&quot;&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;pthread_mutex_destroy(&amp;mutex1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(0&nbsp;==&nbsp;ret)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;&quot;Lock&nbsp;destroy&nbsp;success!&quot;&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;&quot;Lock&nbsp;destroy&nbsp;failed!&quot;&nbsp;&lt;&lt;&nbsp;endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}*/</span><span style="color:#000000;"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">while</span><span style="color:#000000;">(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">return</span><span style="color:#000000;">&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">;<BR>
}</span></div></td></tr></table></div>
<br>
<br><font color=black size = 5><a name="bc6">读写锁概述</a></font>
<br> ✦ 与互斥量类似，但读写锁允许更高的并行性。其特性为：写独占，读共享。
<br>
<br><font color=black size = 5><a name="bc7">读写锁状态</a></font>
<br> ✦ 一把读写锁具备三种状态：
<br>&nbsp;&nbsp;&nbsp;&nbsp; 0、读模式下加锁状态 (读锁)
<br>&nbsp;&nbsp;&nbsp;&nbsp; 1、写模式下加锁状态 (写锁)
<br>&nbsp;&nbsp;&nbsp;&nbsp; 2、不加锁状态
<br>
<br><font color=black size = 5><a name="bc7">读写锁特性</a></font>
<br>  0、读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。
<br>  1、读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。
<br>  2、读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高
<br> ✦ 读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。写独占、读共享。
<br> ✦ 读写锁非常适合于对数据结构读的次数远大于写的情况。
<br>
<br><font color=black size = 5><a name="bc8">主要函数及应用</a></font>
<br> ✦ pthread_rwlock_init() 函数
<br> ✦ pthread_rwlock_destroy() 函数
<br> ✦ pthread_rwlock_rdlock() 函数
<br> ✦ pthread_rwlock_wrlock() 函数
<br> ✦ pthread_rwlock_tryrdlock() 函数
<br> ✦ pthread_rwlock_trywrlock() 函数
<br> ✦ pthread_rwlock_unlock() 函数
<br>  以上7 个函数的返回值都是：成功返回0， 失败直接返回错误号。
<br> ✦ pthread_rwlock_t类型 用于定义一个读写锁变量。
<br> ✦ pthread_rwlock_t rwlock;
<br> ✧ pthread_rwlock_init() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 初始化一把读写锁
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);
<br>&nbsp;&nbsp;&nbsp;&nbsp; 参数2：attr表读写锁属性，通常使用默认属性，传NULL即可。
<br> ✧ pthread_rwlock_destroy() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 销毁一把读写锁
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
<br> ✧ pthread_rwlock_rdlock() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 以读方式请求读写锁。（常简称为：请求读锁）
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
<br> ✧ pthread_rwlock_wrlock() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 以写方式请求读写锁。（常简称为：请求写锁）
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
<br> ✧ pthread_rwlock_unlock() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 解锁
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
<br> ✧ pthread_rwlock_tryrdlock() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 非阻塞以读方式请求读写锁（非阻塞请求读锁）
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
<br> ✧ pthread_rwlock_trywrlock() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 非阻塞以写方式请求读写锁（非阻塞请求写锁）
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
<br> 👦 编程实战：读写锁示例，同时有多个线程对同一全局数据读、写操作。
<br><div style="width:100%;border:1px #e3e3e3 solid;"><div style="width:100%;font-family:'Consolas', 'Courier New';font-size:12px;border-bottom:1px solid #e3e3e3;margin-top:5px;color:#000000;">&nbsp;C++ Code&nbsp;</div><table style="width:100%;font-family:'Consolas', 'Courier New';font-size:12px;vertical-align:text-top;line-height:15px;" border="0" cellspacing="0" cellpadding="0"><tr><td style="color:#008284;background-color:#e3e3e3;vertical-align:text-top;"><div style="margin:7px;text-align:right;white-space:nowrap;"><nobr>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br></nobr></div></td><td style="background-color:#008284;padding:1px;"><div style="border:1px #008284 solid;"></div></td><td style="background-color:#efefef;width:100%;vertical-align:text-top;color:#000000;"><div style="margin:7px;"><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;stdio.h&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;unistd.h&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;pthread.h&gt;<BR>
<BR>
</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;counter;<BR>
pthread_rwlock_t&nbsp;rwlock;<BR>
<BR>
</span><span style="color:#008000;">/*&nbsp;3个线程不定时写同一全局资源，5个线程不定时读同一全局资源&nbsp;*/</span><span style="color:#000000;"><BR>
</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*th_write(</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*arg)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;t,&nbsp;i&nbsp;=&nbsp;(</span><span style="color:#8000ff;">int</span><span style="color:#000000;">)arg;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">while</span><span style="color:#000000;">&nbsp;(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_rwlock_wrlock(&amp;rwlock);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;=&nbsp;counter;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usleep(</span><span style="color:#ff0000;">1000</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span style="color:#800000;">&quot;---write&nbsp;%d:&nbsp;%lu:&nbsp;counter=%d&nbsp;++counter=%d\n&quot;</span><span style="color:#000000;">,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i,&nbsp;pthread_self(),&nbsp;t,&nbsp;++counter);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_rwlock_unlock(&amp;rwlock);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usleep(</span><span style="color:#ff0000;">10000</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">return</span><span style="color:#000000;">&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">;<BR>
}<BR>
</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*th_read(</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*arg)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;i&nbsp;=&nbsp;(</span><span style="color:#8000ff;">int</span><span style="color:#000000;">)arg;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">while</span><span style="color:#000000;">&nbsp;(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_rwlock_rdlock(&amp;rwlock);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span style="color:#800000;">&quot;---read&nbsp;%d:&nbsp;%lu:&nbsp;%d\n&quot;</span><span style="color:#000000;">,&nbsp;i,&nbsp;pthread_self(),&nbsp;counter);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_rwlock_unlock(&amp;rwlock);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usleep(</span><span style="color:#ff0000;">2000</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">return</span><span style="color:#000000;">&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">;<BR>
}<BR>
</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;main(</span><span style="color:#8000ff;">void</span><span style="color:#000000;">)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;tid[</span><span style="color:#ff0000;">8</span><span style="color:#000000;">];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_rwlock_init(&amp;rwlock,&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">for</span><span style="color:#000000;">&nbsp;(i&nbsp;=&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">;&nbsp;i&nbsp;&lt;&nbsp;</span><span style="color:#ff0000;">3</span><span style="color:#000000;">;&nbsp;i++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid[i],&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">,&nbsp;th_write,&nbsp;(</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*)i);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">for</span><span style="color:#000000;">&nbsp;(i&nbsp;=&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">;&nbsp;i&nbsp;&lt;&nbsp;</span><span style="color:#ff0000;">5</span><span style="color:#000000;">;&nbsp;i++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid[i+</span><span style="color:#ff0000;">3</span><span style="color:#000000;">],&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">,&nbsp;th_read,&nbsp;(</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;*)i);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">for</span><span style="color:#000000;">&nbsp;(i&nbsp;=&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">;&nbsp;i&nbsp;&lt;&nbsp;</span><span style="color:#ff0000;">8</span><span style="color:#000000;">;&nbsp;i++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(tid[i],&nbsp;</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_rwlock_destroy(&amp;rwlock);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">return</span><span style="color:#000000;">&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">;<BR>
}</span></div></td></tr></table></div>
<br>
<br><font color=black size = 5><a name="bc9">条件变量概述</a></font>
<br> ✦ 条件变量本身不是锁，但是它也可以造成线程阻塞，通常与互斥锁配合使用，给多线程提供一个会合的场所。
<br>
<br><font color=black size = 5><a name="bc10">主要函数及应用</a></font>
<br> ✦ pthread_cond_init() 函数
<br> ✦ pthread_cond_destroy() 函数
<br> ✦ pthread_cond_wait() 函数
<br> ✦ pthread_cond_timedwait() 函数
<br> ✦ pthread_cond_signal() 函数
<br> ✦ pthread_cond_broadcast() 函数
<br>  以上6 个函数的返回值都是：成功返回0， 失败直接返回错误号。
<br> ✦ pthread_cond_t 类型，用于定义条件变量
<br> ✦ pthread_cond_t cond;
<br> ✧ pthread_cond_init() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 初始化一个条件变量
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);
<br>&nbsp;&nbsp;&nbsp;&nbsp; 参数2：attr表条件变量属性，通常为默认值，传NULL即可
<br>&nbsp;&nbsp;&nbsp;&nbsp; 也可以使用静态初始化的方法，初始化条件变量：
<br>&nbsp;&nbsp;&nbsp;&nbsp; pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
<br> ✧ pthread_cond_destroy() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 销毁一个条件变量
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_cond_destroy(pthread_cond_t *cond);
<br> ✧ pthread_cond_wait() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 阻塞等待一个条件变量
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);
<br>&nbsp;&nbsp;&nbsp; 函数作用：
<br>&nbsp;&nbsp;&nbsp;&nbsp; 0、阻塞等待条件变量cond(参数1)满足
<br>&nbsp;&nbsp;&nbsp;&nbsp; 1、释放已掌握的互斥锁 (解锁互斥量) 相当于pthread_mutex_unlock(&amp;mutex);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0和1 两步为一个原子操作。
<br>&nbsp;&nbsp;&nbsp;&nbsp; 2、当被唤醒，pthread_cond_wait() 函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);
<br> ✧ pthread_cond_timedwait() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 限时等待一个条件变量
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);
<br>&nbsp;&nbsp;&nbsp;&nbsp; 参数3：参看man sem_timedwait函数，查看struct timespec结构体。
<br>&nbsp;&nbsp;&nbsp;&nbsp; struct timespec {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t tv_sec;       /* seconds */ 秒
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long   tv_nsec;   /* nanosecondes*/ 纳秒
<br>&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp;&nbsp; 形参abstime：绝对时间。<br>&nbsp;&nbsp;&nbsp;&nbsp; 如：time(NULL)返回的就是绝对时间。而alarm(1)是相对时间，相对当前时间定时1秒钟。
<br>&nbsp;&nbsp;&nbsp;&nbsp; struct timespec t = {1, 0};
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 只能定时到 1970年1月1日 00:00:01秒(Unix计时元年)
<br>&nbsp;&nbsp;&nbsp;&nbsp; 正确用法：
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t cur = time(NULL); 获取当前时间。
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct timespec t; 定义timespec 结构体变量t
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.tv_sec = cur+1; 定时1秒
<br>&nbsp;&nbsp;&nbsp;&nbsp; pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t);  传参
<br>&nbsp;&nbsp;&nbsp;&nbsp; 在讲解setitimer函数时我们还提到另外一种时间类型：
<br>&nbsp;&nbsp;&nbsp;&nbsp; struct timeval {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t      tv_sec;  /* seconds */ 秒
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; suseconds_t tv_usec;     /* microseconds */ 微秒
<br>&nbsp;&nbsp;&nbsp;&nbsp; };
<br> ✧ pthread_cond_signal() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 唤醒至少一个阻塞在条件变量上的线程
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_cond_signal(pthread_cond_t *cond);
<br> ✧ pthread_cond_broadcast() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 唤醒全部阻塞在条件变量上的线程
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_cond_broadcast(pthread_cond_t *cond);
<br>
<br><font color=black size = 5><a name="bc11">条件变量的优点</a></font>
<br> ✦ 相较于mutex而言，条件变量可以减少竞争。
<br> ✦ 如果直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚(链表)中没有数据，消费者之间竞争互斥锁是无意义的，有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争，从而提高了程序效率。
<br>
<br><font color=black size = 5><a name="bc12">信号量概述</a></font>
<br> ✦ 进化版的互斥锁（1 → N）
<br> ✦ 由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。
<br> ✦ 信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。
<br>
<br><font color=black size = 5><a name="bc13">信号量基本操作、主要函数及应用</a></font>
<br> ✦ sem_init() 函数
<br> ✦ sem_destroy() 函数
<br> ✦ sem_wait() 函数
<br> ✦ sem_trywait() 函数
<br> ✦ sem_timedwait() 函数
<br> ✦ sem_post() 函数
<br>  以上6 个函数的返回值都是：成功返回0， 失败返回-1，同时设置errno。(注意，它们没有pthread前缀)
<br> ✦ sem_t类型，本质仍是结构体，但在应用期间可简单看作为整数，忽略实现细节（类似于使用文件描述符）。
<br> ✦ sem_t sem; 规定信号量sem不能 &lt; 0，头文件 <semaphore.h>
<br> ✦ sem_wait:   0、信号量大于0，则信号量--(类比pthread_mutex_lock)
<br> ✦ 1、信号量等于0，造成线程阻塞 | 对应 | sem_post：将信号量++，同时唤醒阻塞在信号量上的线程 (类比pthread_mutex_unlock)
<br> ✦ 但是由于sem_t的实现对用户隐藏，所以所谓的++、--操作只能通过函数来实现，而不能直接++、--符号。
<br> ✦ 信号量的初值，决定了占用信号量的线程的个数。
<br> ✧ sem_init() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 初始化一个信号量
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int sem_init(sem_t *sem, int pshared, unsigned int value);
<br>&nbsp;&nbsp;&nbsp;&nbsp; 参数1：sem信号量
<br>&nbsp;&nbsp;&nbsp;&nbsp; 参数2：pshared取0用于线程间；取非0(一般为1)用于进程间
<br>&nbsp;&nbsp;&nbsp;&nbsp; 参数3：value指定信号量初值
<br> ✧ sem_destroy() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 销毁一个信号量
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int sem_destroy(sem_t *sem);
<br> ✧ sem_wait() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 给信号量加锁 --
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int sem_wait(sem_t *sem);
<br> ✧ sem_post() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 给信号量解锁 ++
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int sem_post(sem_t *sem);
<br> ✧ sem_trywait() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 尝试对信号量加锁 --    (与sem_wait的区别类比lock和trylock)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int sem_trywait(sem_t *sem);
<br> ✧ sem_timedwait() 函数
<br>&nbsp;&nbsp;&nbsp;&nbsp; 限时尝试对信号量加锁 --
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
<br>&nbsp;&nbsp;&nbsp;&nbsp; 参数2：abs_timeout采用的是绝对时间。
<br>&nbsp;&nbsp;&nbsp;&nbsp; 定时1秒：
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t cur = time(NULL); 获取当前时间。
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct timespec t; 定义timespec 结构体变量t
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.tv_sec = cur+1; 定时1秒
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.tv_nsec = t.tv_sec +100;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sem_timedwait(&amp;sem, &amp;t); 传参
<br>
<br><font color=black size = 5><a name="bc14">进程同步</a></font>
<br><font color=black size = 5><a name="bc14">互斥量 mutex</a></font>
<br> ✦ 进程间也可以使用互斥锁，来达到同步的目的，但是需要在pthread_mutex_init() 初始化之前，修改其属性为进程间共享，mutex的属性修改函数主要有以下几个。
<br>
<br><font color=black size = 5><a name="bc15">主要函数及应用</a></font>
<br>&nbsp;&nbsp;&nbsp;&nbsp; pthread_mutexattr_t mattr 类型：用于定义mutex锁的【属性】
<br> ✧ pthread_mutexattr_init() 函数：初始化一个mutex属性对象
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_mutexattr_init(pthread_mutexattr_t *attr);
<br> ✧ pthread_mutexattr_destroy() 函数：销毁mutex属性对象 (而非销毁锁)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
<br> ✧ pthread_mutexattr_setpshared() 函数：修改mutex属性。
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 🎈 int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);
<br>&nbsp;&nbsp;&nbsp;&nbsp; 参数2：pshared取值：
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 线程锁：PTHREAD_PROCESS_PRIVATE (mutex的默认属性即为线程锁，进程间私有)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 进程锁：PTHREAD_PROCESS_SHARED
<br> 👦 进程间mutex示例：进程间使用mutex来实现同步
<br><div style="width:100%;border:1px #e3e3e3 solid;"><div style="width:100%;font-family:'Consolas', 'Courier New';font-size:12px;border-bottom:1px solid #e3e3e3;margin-top:5px;color:#000000;">&nbsp;C++ Code&nbsp;</div><table style="width:100%;font-family:'Consolas', 'Courier New';font-size:12px;vertical-align:text-top;line-height:15px;" border="0" cellspacing="0" cellpadding="0"><tr><td style="color:#008284;background-color:#e3e3e3;vertical-align:text-top;"><div style="margin:7px;text-align:right;white-space:nowrap;"><nobr>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br></nobr></div></td><td style="background-color:#008284;padding:1px;"><div style="border:1px #008284 solid;"></div></td><td style="background-color:#efefef;width:100%;vertical-align:text-top;color:#000000;"><div style="margin:7px;"><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;fcntl.h&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;pthread.h&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;sys/mman.h&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;sys/wait.h&gt;<BR>
<BR>
</span><span style="color:#0000ff;">struct</span><span style="color:#000000;">&nbsp;mt&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;num;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_t&nbsp;mutex;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutexattr_t&nbsp;mutexattr;<BR>
};<BR>
<BR>
</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;main(</span><span style="color:#8000ff;">void</span><span style="color:#000000;">)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;fd,&nbsp;i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">struct</span><span style="color:#000000;">&nbsp;mt&nbsp;*mm;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pid_t&nbsp;pid;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;fd&nbsp;=&nbsp;open(</span><span style="color:#800000;">&quot;mt_test&quot;</span><span style="color:#000000;">,&nbsp;O_CREAT&nbsp;|&nbsp;O_RDWR,&nbsp;</span><span style="color:#ff0000;">0777</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ftruncate(fd,&nbsp;</span><span style="color:#0000ff;">sizeof</span><span style="color:#000000;">(*mm));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mm&nbsp;=&nbsp;mmap(</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">,&nbsp;</span><span style="color:#0000ff;">sizeof</span><span style="color:#000000;">(*mm),&nbsp;PROT_READ|PROT_WRITE,&nbsp;MAP_SHARED,&nbsp;fd,&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;close(fd);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;unlink(</span><span style="color:#800000;">&quot;mt_test&quot;</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//mm&nbsp;=&nbsp;mmap(NULL,&nbsp;sizeof(*mm),&nbsp;PROT_READ|PROT_WRITE,&nbsp;MAP_SHARED|MAP_ANON,&nbsp;-1,&nbsp;0);<BR>
</span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;memset(mm,&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">,&nbsp;</span><span style="color:#0000ff;">sizeof</span><span style="color:#000000;">(*mm));<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//初始化mutex属性对象<BR>
</span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutexattr_init(&amp;mm-&gt;mutexattr);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//修改属性为进程间共享<BR>
</span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutexattr_setpshared(&amp;mm-&gt;mutexattr,&nbsp;PTHREAD_PROCESS_SHARED);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_init(&amp;mm-&gt;mutex,&nbsp;&amp;mm-&gt;mutexattr);&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//初始化一把mutex琐<BR>
</span><span style="color:#000000;"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;pid&nbsp;=&nbsp;fork();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">if</span><span style="color:#000000;">&nbsp;(pid&nbsp;==&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">for</span><span style="color:#000000;">&nbsp;(i&nbsp;=&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">;&nbsp;i&nbsp;&lt;&nbsp;</span><span style="color:#ff0000;">10</span><span style="color:#000000;">;&nbsp;i++)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_lock(&amp;mm-&gt;mutex);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(mm-&gt;num)++;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span style="color:#800000;">&quot;-child----num++&nbsp;&nbsp;&nbsp;%d\n&quot;</span><span style="color:#000000;">,&nbsp;mm-&gt;num);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_unlock(&amp;mm-&gt;mutex);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;</span><span style="color:#0000ff;">else</span><span style="color:#000000;">&nbsp;</span><span style="color:#0000ff;">if</span><span style="color:#000000;">&nbsp;(pid&nbsp;&gt;&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">for</span><span style="color:#000000;">&nbsp;(&nbsp;i&nbsp;=&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">;&nbsp;i&nbsp;&lt;&nbsp;</span><span style="color:#ff0000;">10</span><span style="color:#000000;">;&nbsp;i++)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_lock(&amp;mm-&gt;mutex);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mm-&gt;num&nbsp;+=&nbsp;</span><span style="color:#ff0000;">2</span><span style="color:#000000;">;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span style="color:#800000;">&quot;-parent---num+=2&nbsp;&nbsp;%d\n&quot;</span><span style="color:#000000;">,&nbsp;mm-&gt;num);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_unlock(&amp;mm-&gt;mutex);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait(</span><span style="color:#0000ff;">NULL</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutexattr_destroy(&amp;mm-&gt;mutexattr);&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//销毁mutex属性对象<BR>
</span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_destroy(&amp;mm-&gt;mutex);&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//销毁mutex<BR>
</span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;munmap(mm,</span><span style="color:#0000ff;">sizeof</span><span style="color:#000000;">(*mm));&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//释放映射区<BR>
</span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">return</span><span style="color:#000000;">&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">;<BR>
}</span></div></td></tr></table></div>
<br>
<br><font color=black size = 5><a name="bc16">文件锁概述</a></font>
<br> ✦ 借助 fcntl() 函数来实现锁机制，操作文件的进程没有获得锁时，可以打开，但无法执行read、write操作。
<br>
<br><font color=black size = 5><a name="bc17">相关函数及应用</a></font>
<br> ✦ fcntl函数：获取、设置文件访问控制属性。
<br> ✦ int fcntl(int fd, int cmd, ... /* arg */ );
<br>&nbsp;&nbsp;&nbsp;&nbsp; 参数2：
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F_SETLK (struct flock *)    设置文件锁（trylock）
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F_SETLKW (struct flock *)    设置文件锁（lock）W --&gt; wait
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F_GETLK (struct flock *)    获取文件锁
<br>&nbsp;&nbsp;&nbsp;&nbsp; 参数3：
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   struct flock {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short l_type;     锁的类型：F_RDLCK 、F_WRLCK 、F_UNLCK
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short l_whence;   偏移位置：SEEK_SET、SEEK_CUR、SEEK_END
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; off_t l_start;       起始偏移：1000
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; off_t l_len;         长度：0表示整个文件加锁
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pid_t l_pid;         持有该锁的进程ID：(F_GETLK only)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };
<br> 👦 进程间文件锁示例：多个进程对加锁文件进行访问<br />
<br><div style="width:100%;border:1px #e3e3e3 solid;"><div style="width:100%;font-family:'Consolas', 'Courier New';font-size:12px;border-bottom:1px solid #e3e3e3;margin-top:5px;color:#000000;">&nbsp;C++ Code&nbsp;</div><table style="width:100%;font-family:'Consolas', 'Courier New';font-size:12px;vertical-align:text-top;line-height:15px;" border="0" cellspacing="0" cellpadding="0"><tr><td style="color:#008284;background-color:#e3e3e3;vertical-align:text-top;"><div style="margin:7px;text-align:right;white-space:nowrap;"><nobr>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br></nobr></div></td><td style="background-color:#008284;padding:1px;"><div style="border:1px #008284 solid;"></div></td><td style="background-color:#efefef;width:100%;vertical-align:text-top;color:#000000;"><div style="margin:7px;"><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;stdio.h&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;fcntl.h&gt;<BR>
</span><span style="color:#0000ff;">#include</span><span style="color:#000000;">&nbsp;&lt;unistd.h&gt;<BR>
<BR>
</span><span style="color:#8000ff;">void</span><span style="color:#000000;">&nbsp;sys_err(</span><span style="color:#8000ff;">char</span><span style="color:#000000;">&nbsp;*str)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;perror(str);&nbsp;exit(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
}<BR>
</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;main(</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;argc,&nbsp;</span><span style="color:#8000ff;">char</span><span style="color:#000000;">&nbsp;*argv[])<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#8000ff;">int</span><span style="color:#000000;">&nbsp;fd;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">struct</span><span style="color:#000000;">&nbsp;flock&nbsp;f_lock;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">if</span><span style="color:#000000;">&nbsp;(argc&nbsp;&lt;&nbsp;</span><span style="color:#ff0000;">2</span><span style="color:#000000;">)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span style="color:#800000;">&quot;./a.out&nbsp;filename\n&quot;</span><span style="color:#000000;">);&nbsp;exit(</span><span style="color:#ff0000;">1</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">if</span><span style="color:#000000;">&nbsp;((fd&nbsp;=&nbsp;open(argv[</span><span style="color:#ff0000;">1</span><span style="color:#000000;">],&nbsp;O_RDWR))&nbsp;&lt;&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys_err(</span><span style="color:#800000;">&quot;open&quot;</span><span style="color:#000000;">);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">//f_lock.l_type&nbsp;=&nbsp;F_WRLCK;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*选用写琐*/<BR>
</span><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;f_lock.l_type&nbsp;=&nbsp;F_RDLCK;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">/*选用读琐*/</span><span style="color:#000000;">&nbsp;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;f_lock.l_whence&nbsp;=&nbsp;SEEK_SET;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;f_lock.l_start&nbsp;=&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;f_lock.l_len&nbsp;=&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#008000;">/*&nbsp;0表示整个文件加锁&nbsp;*/</span><span style="color:#000000;"><BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;fcntl(fd,&nbsp;F_SETLKW,&nbsp;&amp;f_lock);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span style="color:#800000;">&quot;get&nbsp;flock\n&quot;</span><span style="color:#000000;">);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;sleep(</span><span style="color:#ff0000;">10</span><span style="color:#000000;">);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;f_lock.l_type&nbsp;=&nbsp;F_UNLCK;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;fcntl(fd,&nbsp;F_SETLKW,&nbsp;&amp;f_lock);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span style="color:#800000;">&quot;un&nbsp;flock\n&quot;</span><span style="color:#000000;">);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;close(fd);&nbsp;&nbsp;&nbsp;</span><span style="color:#0000ff;">return</span><span style="color:#000000;">&nbsp;</span><span style="color:#ff0000;">0</span><span style="color:#000000;">;<BR>
}</span></div></td></tr></table></div>
<br>依然遵循“读共享、写独占”特性，但是如若进程不加锁直接操作文件，依然可访问成功，但数据势必会出现混乱。
<br> 👦 思考：多线程中，可以使用文件锁吗？
<br>&nbsp;&nbsp;&nbsp;&nbsp; 多线程间共享文件描述符，而给文件加锁，是通过修改文件描述符所指向的文件结构体中的成员变量来实现的。因此，多线程中无法使用文件锁。</p>

<p><br><br><br>
<font color = gray size = 3>如有错误，欢迎指正！</font></p></div>
        <div class="post_footer">
          
          <div class="meta">
            <div class="info">
              <span class="field tags">
                <i class="remixicon-stack-line"></i>
                
                <a href="https://oubc.github.io/tags/linux/">Linux</a>
                
              </span>
            </div>
          </div>
          
        </div>
      </div>
      
      
    </div>
  </div>
  <a id="back_to_top" href="#" class="back_to_top"><span>△</span></a>
</div>
<footer class="footer">
  <div class="powered_by">
    <a href="https://wxt.sinaimg.cn/thumb300/007Diza3ly1g4l9lmg4aog3074074gnf.gif?tags=%5B%5D">I </a>
	<a href="">love</a>
    <a href="https://wxt.sinaimg.cn/thumb300/007Diza3ly1g4l9lmfm2eg306o06o74u.gif?tags=%5B%5D"> you </a>
    <a href="https://wxt.sinaimg.cn/thumb300/007Diza3ly1g4njrx4tpcj30fn0bq3zg.jpg?tags=%5B%5D">three </a>
	<a href="https://wxt.sinaimg.cn/thumb300/007Diza3ly1g4njrx64ctg307s07swfy.gif?tags=%5B%5D">thousand</a>
    <a href="https://www.kugou.com/song/#hash=96426C78381DE98DC31A5846FC274CBF&album_id=646623"> times.</a>
  </div>

  <div class="footer_slogan">
    <span>家庭、梦想、内心的平静</span>
  </div>
</footer>



<script src="https://oubc.github.io/js/jquery-3.3.1.min.js"></script>
<script src="https://oubc.github.io/js/zozo.js"></script>
<script src="https://oubc.github.io/js/highlight.pack.js"></script>
<link  href="https://oubc.github.io/css/fancybox.min.css" rel="stylesheet">
<script src="https://oubc.github.io/js/fancybox.min.js"></script>

<script>hljs.initHighlightingOnLoad()</script>


  <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>






</body>
</html>
